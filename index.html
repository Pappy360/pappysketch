<script>
const gallery = document.getElementById('gallery');
const upload = document.getElementById('upload');
const spacing = 10;

let drag = null, offsetX = 0, offsetY = 0;

// Handle image uploads
upload.onchange = e => {
  const files = [...e.target.files];
  const galleryRect = gallery.getBoundingClientRect();
  const newImages = [];

  files.forEach(file => {
    const img = new Image();
    img.src = URL.createObjectURL(file);

    img.onload = () => {
      // Scale images if too wide
      const maxW = 150;
      img.style.width = Math.min(maxW, img.naturalWidth) + 'px';
      img.style.height = img.naturalHeight * (parseInt(img.style.width)/img.naturalWidth) + 'px';

      // Set initial position
      img.style.position = 'absolute';
      img.style.left = '0px';
      img.style.top = '0px';
      img.style.cursor = 'grab';
      img.style.transition = 'left 0.2s, top 0.2s';

      makeDraggable(img);

      gallery.appendChild(img);
      newImages.push(img);

      // Auto-arrange all images including previous ones
      const allImages = [...gallery.querySelectorAll('img')];
      smartArrange(allImages, galleryRect);

      // Release memory
      URL.revokeObjectURL(img.src);
    };
  });

  // Reset file input so same file can be re-uploaded
  upload.value = '';
};

// Make images draggable
function makeDraggable(img){
  img.onmousedown = e => {
    drag = img;
    offsetX = e.pageX - parseInt(img.style.left);
    offsetY = e.pageY - parseInt(img.style.top);
    img.style.transition = 'none';
    img.style.cursor = 'grabbing';
  };
}

window.onmousemove = e => {
  if(!drag) return;
  drag.style.left = e.pageX - offsetX + 'px';
  drag.style.top = e.pageY - offsetY + 'px';
  pushOthers(drag);
};

window.onmouseup = () => {
  if(drag){
    drag.style.transition = 'left 0.2s, top 0.2s';
    drag.style.cursor = 'grab';
  }
  drag = null;
};

// Smart initial arrangement
function smartArrange(images, rect){
  let x = spacing, y = spacing;
  let rowHeight = 0;

  images.forEach(img => {
    const w = parseInt(img.style.width);
    const h = parseInt(img.style.height);

    if(x + w + spacing > rect.width){
      x = spacing;
      y += rowHeight + spacing;
      rowHeight = 0;
    }

    img.style.left = x + 'px';
    img.style.top = y + 'px';

    x += w + spacing;
    rowHeight = Math.max(rowHeight, h);
  });
}

// Prevent overlap while dragging
function pushOthers(dragImg){
  const imgs = [...gallery.querySelectorAll('img')];
  const dragRect = dragImg.getBoundingClientRect();

  imgs.forEach(img => {
    if(img === dragImg) return;
    const r = img.getBoundingClientRect();

    if(isOverlapping(dragRect, r)){
      let topMove = 0, leftMove = 0;

      if(dragRect.bottom > r.top && dragRect.top < r.top){
        topMove = dragRect.bottom - r.top + spacing;
      } else if(dragRect.top < r.bottom && dragRect.bottom > r.bottom){
        topMove = dragRect.top - r.bottom - spacing;
      }

      if(dragRect.right > r.left && dragRect.left < r.left){
        leftMove = dragRect.right - r.left + spacing;
      } else if(dragRect.left < r.right && dragRect.right > r.right){
        leftMove = dragRect.left - r.right - spacing;
      }

      img.style.top = parseInt(img.style.top) + topMove + 'px';
      img.style.left = parseInt(img.style.left) + leftMove + 'px';
    }
  });
}

// Check overlap
function isOverlapping(a, b){
  return !(a.right + spacing < b.left ||
           a.left - spacing > b.right ||
           a.bottom + spacing < b.top ||
           a.top - spacing > b.bottom);
}

// Responsive layout
window.onresize = () => {
  const galleryRect = gallery.getBoundingClientRect();
  const imgs = [...gallery.querySelectorAll('img')];
  if(imgs.length) smartArrange(imgs, galleryRect);
};
</script>
